
# Gem Upgrade – Copilot Instructions

These instructions apply when you are reviewing **Dependabot gem upgrade PRs** in this repository.

The goal: behave like an engineer (understand risk, reason about changes, suggest minimal safe edits and tests), not just restate the diff.

---

## 1. Start from the dependency summary comment

For any **Dependabot** PR that changes `Gemfile`, `Gemfile.lock`, or `*.gemspec`:

1. Find the latest PR comment that starts with:

   ```md
   ## Dependency change summary
   ```

2. This comment is generated automatically by:

   - `.github/workflows/gem-upgrade-review.yml`
   - `.github/scripts/gem_diff.rb`

   It compares `Gemfile.lock` on the base branch vs the PR and lists:

   - Direct vs transitive gems
   - Old and new versions
   - Change type: `major`, `minor`, `patch`, `added`, `removed`
   - Risk level: `High`, `Medium`, `Low`

3. Treat this table as your **source of truth** for:
   - Which gems actually changed
   - How big each change is
   - Where to focus review effort

---

## 2. How to interpret the table

Use the sections in the table:

- **“Direct dependencies (from Gemfile)”**
  - These are the most important; review them first.
- **“Transitive / stdlib gems (from Gemfile.lock only)”**
  - Usually lower risk, but still important when marked `High`.

Use `Change` + `Risk` together:

- **High + major**:
  - High review priority.
  - Check how that gem is used in the code and whether APIs/config changed.
- **Medium + minor**:
  - Scan release notes for behavior changes or deprecations.
- **Low + patch**:
  - Typically bugfixes; confirm tests and usage are still correct.

---

## 3. Copilot review workflow for Dependabot gem PRs

When you review a Dependabot gem PR, follow this workflow:

1. **Summarize the impact**

   - Based on the `## Dependency change summary` table:
     - List which gems changed.
     - Call out any **High** risk or **major** bumps.
   - Explain in plain language what parts of the app/library might be affected.

2. **Inspect usage in this repo**

   - Search for where each changed gem is used:
     - Application/library code using that gem’s classes/modules/methods.
     - Any configuration or initializer files.
     - Any custom wrappers, adapters, or monkey patches.

3. **Reason about compatibility**

   For each risky gem:

   - Check for:
     - Breaking changes / deprecations in changelog or release notes.
     - Methods that were removed or changed behavior.
   - Suggest **minimal, backwards‑compatible edits** such as:
     - Adjusting method calls or options to match new APIs.
     - Updating configs while keeping defaults compatible.

4. **Testing guidance**

   - Recommend **focused tests** first, for example:
     - Unit tests for the areas that use the upgraded gems.
   - For high‑risk upgrades (core libraries, network/db gems), also recommend:
     - Relevant integration/functional tests where these gems are heavily used.

5. **How to structure your review comment**

   When producing the final Copilot review for a Dependabot gem PR:

   - **Summary**:
     - Short summary of which gems changed, using the table.
   - **Risk analysis**:
     - Which changes are High/Medium risk and why.
   - **Code suggestions**:
     - Concrete, minimal code changes to keep behavior correct.
   - **Test plan**:
     - Specific test commands and/or suites that should be run.

---

## 4. Behave like an engineer

When responding as Copilot on these PRs:

- Do **not** just restate the diff or the gem table.
- Do:
  - Use the `## Dependency change summary` comment from `gem_diff.rb` as input.
  - Think about:
    - “What could break because of these gem changes?”
    - “Which files/areas do we need to inspect?”
  - Provide **actionable, specific** suggestions:
    - Exact files/lines to review.
    - Concrete code edits when safe.
    - Clear test recommendations.

Your goal is to help humans safely merge Dependabot gem upgrades with **clear reasoning and minimal, high‑value changes**, using the summary generated by `gem_diff.rb` as your starting point.

---

## 5. Implementing gem upgrade fixes

When you need to **implement code changes** to fix failing tests caused by gem upgrades, follow this pattern:

### The `dependency_upgraded_next?` feature flag pattern

**Goal**: Deploy the same codebase with:
- Old gem versions (safe, current production)
- New gem versions (for testing)

**Rules**:
1. **NEVER touch old code paths** - existing code must work exactly as before
2. **ALL new behavior** for upgraded gems must be behind `K2Config.dependency_upgraded_next?`
3. Any Rails-version-specific changes (new APIs, callbacks, controller changes, configs) go **ONLY** in the `dependency_upgraded_next?` branch

### Implementation pattern

```ruby
if K2Config.dependency_upgraded_next?
  # New code for upgraded gem versions
  # Add comment explaining what changed and why
  # Link to relevant changelog: https://github.com/gem-name/releases/...
  new_api_method(new_option: true)
else
  # Original code - DO NOT MODIFY
  old_api_method
end
```

### Required documentation

**Inside `dependency_upgraded_next?` blocks, add comments**:
- What changed in the new gem version
- Link to the relevant changelog or release notes
- Why this change is necessary

**Example**:
```ruby
if K2Config.dependency_upgraded_next?
  # Rails 7.2 changed default session serialization from :marshal to :json_marshal
  # See: https://guides.rubyonrails.org/7_2_release_notes.html#session-serialization
  config.session_store :cookie_store, key: '_app_session', 
                       serializer: :json_marshal
else
  config.session_store :cookie_store, key: '_app_session'
end
```

### Changelog updates

After implementing fixes:
1. Create or update `docs/dependency-upgrades-changelog.md`
2. Add an entry describing:
   - Which gems were upgraded
   - What code changes were made
   - Why the changes were necessary
   - Links to relevant gem changelogs

### Workflow for gem upgrade PRs

1. **Create draft PR first** - Start with a draft PR for all gem upgrade work
2. **Implement fixes** - Add code behind `dependency_upgraded_next?` flag
3. **Add comments** - Document what changed and link to changelogs
4. **Update changelog** - Document in `docs/dependency-upgrades-changelog.md`
5. **Run tests** - Verify both old and new code paths work:
   - Tests run with `dependency_upgraded_next? == false` (default)
   - Tests run with `dependency_upgraded_next? == true` (CI will handle this)
6. **Review your changes** - Verify you followed the pattern correctly:
   - No old code modified
   - All new code behind feature flag
   - Comments and changelog updated
7. **Mark PR ready** - Convert from draft to ready for review

### CI checks

When the PR is ready for review:
- Multiple CI jobs will run
- Pay attention to jobs that run with **current dependencies** (`dependency_upgraded_next? == false`)
- These jobs verify you didn't break existing production behavior

### Example: Fixing a breaking change

**Scenario**: ActiveRecord 7.2 removed `ActiveRecord::Base.connection.tables`

**Wrong approach** ❌:
```ruby
# This breaks existing production code!
ActiveRecord::Base.connection.data_sources
```

**Correct approach** ✅:
```ruby
if K2Config.dependency_upgraded_next?
  # ActiveRecord 7.2 renamed #tables to #data_sources
  # https://github.com/rails/rails/blob/7-2-stable/activerecord/CHANGELOG.md
  ActiveRecord::Base.connection.data_sources
else
  ActiveRecord::Base.connection.tables
end
```
